#include <stdlib.h>
#include <stdio.h> 
#include <malloc.h>
#include <assert.h>
#include<time.h>

// лямбда функция максимума для редукции
#define max(x, y) ((x) > (y) ? (x) : (y) )

int main(int argc, char *argv[])
{
	assert(argc == 4);
	//объявляем "size of matrix", "accurancy" и "iterations_max"
	clock_t start, end;
	double result;

	start = clock();
	int size = atoi(argv[1]);
	double accur = atof(argv[2]);
	int iter_max = atoi(argv[3]);
	
	//смещение массива на 2 индекса:
    // 1 - в связи с тем что происходит обрез тензора по "правому" и "нижнему" краю(<20 а не =20)
    // 2 - в свзи с тем что при пробеге в циклах по тензору по "правому" и "нижнему" краю будет браться
    // мнимый ноль на границах чтобы не выйти за предел тензора (см схему ниже под кодом)
	int bias_1 = 2;
	// создание двумерного массива - тензора с учетом добавления обреза
	// создание двух матриц нужно для того чтобы можно было вычитать ячейки проработанного массива
	// и находить ошибку и быстро переобновлять матрицу
	double **main_arr = (double**)malloc((size + bias_1)* sizeof(double*));
	double **main_arr2 = (double**)malloc((size + bias_1)* sizeof(double*));
	
	for (int i=0;i<size + bias_1;i++)
	{
		main_arr[i] = (double*)malloc((size + bias_1) * sizeof(double));
		main_arr2[i] = (double*)malloc((size + bias_1) * sizeof(double));
	}
	// объявление переменной отсчета итерации и градиента = шага нарастания от одной вершины до другой  
	int iter = 0;
	double gradient = 10.0 / size;
	// объявление переменной ошибки 
	double error = 1.0;
    // двойной указатель на массив как контейнер обмена данными между 2 тензорами
    double **ptr;
    // структурированная - через struct
	/* Так как у нас НЕструктурированая модель данных мы выделяем память на ГПУ под размеры соответствующие
		нашим массивам (только выделяем с помощью create) и ТОЛЬКО копируем данные (copyin) на ГПУ ускоритель и заполняем этот массив на ГПУ памяти
	*/
	#pragma acc enter data create(main_arr[0:size+bias_1][0:size+bias_1],main_arr2[0:size+bias_1][0:size+bias_1]) copyin(size, gradient, bias_1)

	// заполнение ребер тензоров по градиенту, возьмем parallel для небольшого ускорения
    #pragma acc parallel 
    {
        for (int i=0;i<size + bias_1;i++)
        {
            main_arr[i][0] = 10 + gradient*i;
            main_arr[0][i] = 10 + gradient*i;
            main_arr[size][i] = 20 + gradient*i;
            main_arr[i][size] = 20 + gradient*i;
        }
    }
    #pragma acc parallel
    {
        for (int i=0;i<size + bias_1;i++)
        {
            main_arr2[i][0] = 10 + gradient*i;
            main_arr2[0][i] = 10 + gradient*i;
            main_arr2[size][i] = 20 + gradient*i;
            main_arr2[i][size] = 20 + gradient*i;
        }
    }
    /*
        На данном этапе перенесенные переменные выше в диерктиве copyin  автоматически
        удаляются из видеопамяти за ненадобностью в дальнейших вычислениях
        поэтому нужно проинизиализировать повторно но уже только переменную error.
        Так как у нас сама цель просто ее выделить в памяти для дальнейшей обработки
        то можно грубо говоря писать любую директиву выделения(копирования):
        copyin; copyout; create...,
        все равно значение ее мы будем по итогу экспортировать на ЦПУ RAM в директиве:
        #pragma acc update host(error)
    */ 
    #pragma acc data copyout(error)

    /*
        начало цикла внутреннего формирования тензора, где прерыванием будет предел 
        итераций т.е.грубо говоря колличество "Эпох", или предел разницы между двумя ячейками
        тензоров main_arr и main_arr2
    */ 
    while ((error > accur) && (iter<iter_max))
    {
        iter++;

        if ((iter % 150 == 0) || (iter == 1))
        {
            //обнуляем ошибку и создаем для каждого потока дополнительно, чтобы при 
            //распараллеливании они все имели нулевое значение см. ниже под кодом
            #pragma acc parallel
            error = 0.0;

            /*
                На данном этапе мы распалаллеливаем ниже цикл, причем цикл у нас объединен
                из 2 в 1 с помощью gang vector(кол-во блоков) - где указывают что цикл 
                имеет 2 вектора вычисления которые могут обоюдно вычилсятся параллельно
                по сути если смотреть аппаратно мы перенесли наши 2 цикла на двумерный тензор ГПУ,
                в котором абсцисса - сетка или итерации первого цикла, а ордината это блоки или 
                итерации второго цикла. Все они на этом тензоре одновременно проходят по своим потокам
                и таким образом мы грубо говоря за 1 проход пробежали все итерации цикла на тензоре main_arr2
                а это очень сильно ускоряет работу. 
            */
            #pragma acc parallel 
            {
                /*
                    reduction - нужна для ускорения нахождения в нашем случае максимума ошибки
                    архитектура работы - создает массив(вектор) где каждый элемент в ней это вычисленное
                    значение максимума ошибки на потоке, номер которого совпадает с индексом этого массива,
                    что то похожее на хеш-таблицу, когда все потоки найдут в своей итерации значение ошибки и
                    массив заполнится и компиллятор сгенерирует новое ядро где финальной работой будет вычисление максимума
                    из полученного вектор(метод похож на параллельное суммирование)
                */ 
                #pragma acc loop gang vector() reduction(max:error)
                for (int j = 1; j < size + 1; j++)
                {
                    #pragma acc loop gang vector() 
                    for (int i = 1; i < size + 1; i++)
                    {
                        main_arr2[i][j] = 0.25 * (main_arr[i+1][j] + main_arr[i-1][j] + main_arr[i][j-1] + main_arr[i][j+1]);
                        error = max(error, main_arr2[i][j] - main_arr[i][j]);
                    }
                }
            }
        }
        else 
        {
            #pragma acc parallel 
            {
                #pragma acc loop gang vector()
                for (int j = 1; j < size + 1; j++)
                {
                    #pragma acc loop gang vector()
                    for (int i = 1; i < size + 1; i++)
                    {
                        main_arr2[i][j] = 0.25 * (main_arr[i+1][j] + main_arr[i-1][j] + main_arr[i][j-1] + main_arr[i][j+1]);
                    }
                }
            }
        }
        // меняем указатели массивов чтоб обновить полученные значения на первый массив
        ptr = main_arr;
        main_arr = main_arr2;
        main_arr2 = ptr;

        if ((iter % 150 == 0) || (iter == 1))
        {
            #pragma acc update host(error)
            printf("Iteration - %d ; Error = %lf\n", iter, error);
        }

    }


	end = clock();
    result  = (double)(end-start);
    result = result / 1000000;
    printf("Iteration - %d ; Error = %lf\n", iter, error);
    printf("Time = %f Seconds\n", result);

	return 0;

}

/*  схема строения тензора: 8 x 8

g(i) = 10 + gradient*i
f(i) = 20 + gradient*i
i = index

i = {0 .. 7} - 8 элементов
i = i + 2 = {0 .. 9} элементов - 7-ой элемент не равен значению вершины тензора
поэтому мы делаем +1 смещение для получения полного тензора без обреза по краям снизу и справа (index = 8);
далее делаем еще одно смещение +1 где мы получаем два мнимых края тензора c рандомными значеним 
чтобы при применении уравнения теплопроводности на точках (x, 8) и (8, x) где x -> {0 .. 8}
мы не заходили за пределы тензора или за область допустимой памяти:

main_arr2[i][j] = 0.25 * (main_arr[i+1][j] + main_arr[i-1][j] + main_arr[i][j-1] + main_arr[i][j+1]);


_i_|_0 _|_1 _|_2 _|_3 _|_4 _|_5 _|_6 _|_7 _|_8 _|_9 _
_0_|_10_|_1g_|_2g_|_3g_|_4g_|_5g_|_6g_|_7g_|_20_|_??_
_1_|_1g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_1f_|_??_
_2_|_2g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_2f_|_??_
_3_|_3g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_3f_|_??_
_4_|_4g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_4f_|_??_
_5_|_5g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_5f_|_??_
_6_|_6g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_6f_|_??_
_7_|_7g_|_x _|_x _|_x _|_x _|_x _|_x _|_x _|_7f_|_??_
_8_|_20_|_1f_|_2f_|_3f_|_4f_|_5f_|_6f_|_7f_|_30_|_??_
_9_|_??_|_??_|_??_|_??_|_??_|_??_|_??_|_??_|_??_|_??_

*/
